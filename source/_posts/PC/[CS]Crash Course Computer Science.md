---
title: '[CS]Crash Course Computer Science'
date: 2019-11-11 00:00:00
toc: true
---


### 0x00 Preface

[Github] : https://github.com/1c7/crash-course-computer-science-chinese

### 0x01 计算机早期历史



30、字节

Mega(MB)

Giga(GB)

 



 

 

 

ASKII：7位

Mogibake:乱码

Unicode：16

 4、【英文字母占的字节】

不同编码方式1个英文字母占的字节是不同的：

 

1，ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。

2，UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节。

3，Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节。

 

 

 

计算机算术逻辑单元ALU（Arithmetic And Logic Unit）

 

Random Access Memory

Static Random Access Memory

DRAM

NVRAM

闪存

时常困扰我的一个问题是1M到底有多大？1M到底有多小？这里作为我初入计算机这个坑的导线。

`1M(B)=1024K(B)；1K(B)=1024B(字节)；1B(字节)=8位(Bit)；`以上。

而往上则分别有`GB`、`TB`、`PB`、`EB`、`ZB`、`YB`、`BB`、`NB`、`DB`

7. 



### 0x02 电子计算机

涉及的设备：继电器、真空管、晶体管

1. 20世纪的发展需要更强的计算能力，柜子大小的计算机发展到房间大小。
2. 哈佛 Mark 1号是由 IBM 1994年做的
3. 继电器，一秒最多50次开关
4. 继电器出现Bug
5. 1904年，热电子管出现，第一个真空管。改进后变得和继电器的功能一样
6. “巨人一号”计算机在英国 布莱切利园 首次大规模使用真空管。但是编程复杂，还要配置。
7. 1946年宾夕法尼亚大学的ENIAC 是第一个通用可编程的计算机
8. 1947年，贝尔实验室做出晶体管，IBM转向晶体管
9. 硅谷的典故：很多晶体管和半导体都是这里做的。
10. 肖克利半导体=>仙童半导体=>英特尔



### 0x03 布尔逻辑和逻辑门

1. 二进制是什么，为什么使用二进制，布尔逻辑（？？）
2. 3个基本操作：NOT、AND、OR
3. 解释3个基本操作
4. XOR的构成



### 0x04 二进制

1. 十进制演示二进制的原理，存储单位 MB GB TB等
2. 正数、负数、整数、浮点数的表示
3. 美国信息交换标准代码 ASCII ，用来表示字符
4. UNICODE 1992年诞生，是字符编码标准，解决 ASCII 不够表达所有语言的问题



### 0x05 算数逻辑单元

1. ALU 英特尔 74181
   两个单元（算数和逻辑单页）
2. 算数单元
   半加器
   全加器
   8 bit 加法
   溢出的概念
   乘法除法
3. 逻辑单元
   检测数字是否为0 的电路（一堆OR门最后加上NOT门）
   ALU 抽象为一个 V 符号
   Flag标志（是否相等，是否小于，是否溢出等等）



### 0x06 寄存器和内存



### 0x07 中央处理器



### 0x08 指令和程序



### 0x09 高级CPU设计

* 处理器有专门的电路来实现图片操作，解码压缩视频，加密文档。
* 标准操作需要多个时间周期
* MMX，3DNOW，SEE——多余的电路去实现更经一部的操作

 46——1000+ ——超级高的时针转速——快速传数据给CPU

RAM是拖慢CPU运行的瓶颈（CPU空等）（找地址，配置，输出数据）（读去所需的要多个时间周期）

cache是解决此类问题的 （KB/MB）和RAM的数量差也是问题

已有缓存（cache hit）&&缓存未命中 

缓存脏位（DIRTY BIT）

同步——缓存满了但是CPU又要缓存—>回查是否是脏位—>写会RAM

指令流水线——并行处理（PARAII FLIZE）——处理器的运行方式

取值——解码——执行，不断重复（下一位的指令前移n-1位）处理量=*N

* （指令之间的依赖性 ——必要时停止流水线）

  * （？动态排序——最小化流水线停工时间）（OUT-OF-ORFER EXWCUTION）(乱序执行)

  *  条件跳转（改变执行流）——高端处理器的“推测执行”(后期厂商的优化，分支预测)

    else 清空流水线  	（PIPELINE FLUSH）

* 超标处理器

  * 优化一个指令流的吞吐量（加相同的电路处理频次高的指令—>多个独立的ALU）
  * 同时运行多个指令流——多核处理器 （独立处理单元（共享缓存+合作运算）（多核不够的时候，上多个CPU））

* 超级计算机——模拟宇宙的形成
  
  * 中国无锡的国家超算中心——神威·太湖之光



### 0x0a 早期的编程方式

##### 最早的可编程的物品——纺织机（亚卡尔织布机）

* 每一行的图案由可穿孔卡纸决定UARD——线高线低

* 连续指令时的图案更加丰富

##### 控制面板——执行不同的计算(PLUGBOARDS"插线板")

* 插线板的编程对象的变换 ——机电计算机（ENIAC）——渴求更快更灵活 
* 1940-1950内存变得可行——存储程序计算机（STORED-PROGRAM COMPUTERS）
* 存储的的地方——冯诺依曼体系——（1948）“绰号宝宝”——数据输入——穿孔卡片

##### 新的编程方式——（PANEL PROGRAMMING）

* 商用计算机——altair 8800
* 门槛——底层硬件
* 优化——PROGRAMMING LANGUAGE



### 0x0b编程语言与发展

* 操作码（4）+ 内存地址（4）
* “操作码表”—>伪代码—>二进制机器码
* 1940*1950—>“助记符”+数据
* 发明汇编器
* 在需要的地方插入代码用goto，而不是得重新更新程序

* 变量的抽象就是地址的抽象（COBOL）
* 正是语言才是大众化的桥梁

* 60年代：ALGOL，LISP，BASIC
* 70年代：Pascal，C和Smalltalk 
* 80年代：C++，Objective-C，Perl
* 90年代：Python，Ruby和Java
* 新千年：Swift，C#，Go

![语言](C:\Users\15517\Desktop\个人文档\【IMU】\Markdown\变易语言的种类繁多.png)



### 0x0c 编译原理 语句和函数

0x0d 语句

 ——语法

 控制流语句



### 0x0d 算法入门——运行步骤和输入大小之间的关系



### 0x0e 数据结构



### 0x0f 阿兰图灵



### 0x10软件工程



### 0x11 集成电路&&摩尔定律

集成开发环境 
电子管到晶体管 
仙童半导体让集成电路成为可嫩
PCB 蚀刻金属线——PCB和IC结合
光刻技术 把复杂图案印在材料上

晶圆开始
半导体通过控制导电时机
晶体管更小密度更高， 切换状态更快，耗电少

1970年超大规模集成（VLSI）软件自动生产芯片设计
光的波长导致精度达到极致——波长更短、投射更小
量子隧穿效应——电极之间的极速靠近导致电子跳跃

如何判断是否是小数？？

### 0x12 操作系统（OS）——目的：让计算机自动运行
一种拥有操作硬件的特殊权利来运行软件和管理其他程序
为了避免繁琐的软硬件交互，操作系统是作为硬件和软件之间的媒介
开始于1950年，可以实现进程的连续运行，以避免时间的浪费，被叫做批处理。同十年年末CPU的告诉发展带动机械设备的发展
操作系统提供API来抽象硬件，叫做“设备驱动程序”（device drives）
通过标准化机制和输入输出硬件（I/O）交互

#### 多线程
Atlas通过调度解决可以在一个CPU上运行多个程序，在单个CPU上共享时间，这种操作叫做多任务处理
操作系统将不连续的内存虚拟化，叫做“虚拟内存”，程序可以假定内存总是从0开始，这样就不必时时刻刻追踪内存了
操作系统会自动处理虚拟内存和实际内存之间的映射，这种机制使得内存可以灵活增删，叫做“动态内存分配”，这样子也不会影响其他内存，叫做“内存保护”
以上两种机制是进行多任务处理的必不可少的条件

#### Multics
1969年后期发展出一个主计算机和多个终端——分时操作系统（Multics）（多任务信息与计算系统）最大的特点：考虑安全（防止恶意用户访问非法内存）
#### Unix
受限于内存保护的复杂度上升，开发出了替代品——Unix
将内存分为两部分：一是核心部分“内核”，二是一对有用的工具（程序和运行库）
将以前的系统恢复直接压缩为“内核恐慌”（调用一个恐慌的函数，无线循环打印恐慌），需要重启电脑，得到用户的一致好评
1971年顺势成为最流行的语言
#### 个人电脑的出现
微软的磁盘操作系统（MS-DOS）（160k）

### 0x13 内存&&存储介质



###  0x14 文件与文件系统

1. 文件格式：可以随便存文件数据，但按格式会更方便
   1. TXT文本文件：ASKII
   2. WAV音频文件：每秒上千次的采集数字
   3. BMP图片文件：像素的红绿蓝 RGB 值
2. 文件系统：很早期时空间小，整个储存器就像是一整个文件，后期多文件很重要
3. 目录系统：同来解决多文件问题，存其他文件的信息，比如开头、结尾、创建时间等
4. 平面目录系统：—Flat Film System：文件都在同一个层次，早期空间小，只有十几个文件，平面系统够用
5. 如果文件紧密的一个个前后排序造成问题，所以文件系统会：
   1. 空间划分块
   2. 文件拆分存在多个块中
6. 文件的增删查改会不可避免的造成文件散落在各个块中
   如果是磁带这样的存储介质就会造成问题，所以做碎片整理
7. 分层文件系统 —Hierarchical File System：有不同文件夹，文件夹可以层层嵌套

### 0x15 文件压缩

1. 压缩的好处是能存更多的文件，传输也更快
   1. 游码编程
   2. 无损压缩
   3. 霍夫曼树
   4. “消除冗余”和“用更紧凑的表示方法”，混合使用
   5. 字典编码
   6. 感知编码
   7. 有损压缩
   8. 时间冗余
   9. MPEG-4视频编码

### 0x16 命令行界面

1. 人机交互
2. 早期输入数据是打印到纸上，而输入是用纸纸卡一次性把程序和数据都给进去
3. QWERTY 打字机的发展，克里斯托弗·莱瑟姆·肖尔斯 发明于1868年
4. 电传打字机
5. 命令行界面
6. ls命令
7. 早期文字游戏  Zork （1977年）
8. cd命令

### 0x17 屏幕与2D图形显示

1. PDP-1计算机、键盘与显示器分开，屏幕显示临时值
   1. PDP-1（Programmed Data Processor-1），程序数据处理机１号 , 是形成骇客文化的重要推手。史上第一个电脑游戏是在这个平台上开发的（一段简单的FORTRAN程序。在这个程序里，Crowther设计了一张地图，地图上不规则的分布着陷阱，游戏者必须寻找路径避开陷阱）

      其磁芯内存的周期时间是**5.35微秒**(换算成**时脉频率**约**187千赫兹**)。大部分算数指令需要10.7微秒来完成(亦即约**每秒完成93458个运算**)，这是因为这些指令运算需要使用两个内存周期：第一个周期用来**取得指令**，而第二个周期用来**存取数据**。

      PDP-1的晶体管数量为2700个，并且拥有3000个二极管
      
   2. 文本任务 和 图像任务是分开的。因为早期的屏幕分辨率连纸都不如。**早期的屏幕的值更多是追踪程序的值（比如寄存器的值）**
   
   
   
2. 阴极射线管（CRT）（原理是：把电子发射到有碳光体涂层的屏幕上，当电子撞击涂层时会发光几分之一秒，由于电子是带电拉子。略径可以用磁场控制，屏幕内用板子或线圈把电子引导到想要的位置）
   既然可以这样控制。 有2种方法绘制图形1，
   
   1. 矢量扫描：引导电子末描绘出形状。因为发光只持续一小会儿，如果重复得足够决可以得到清晰的图像
   2. 光栅扫描：按固定路径。一行行来从上向下。从左到右。不断重复。只在特定的点打开电子束。以此绘制图形。用这种方法。可以用很多小线联绘制形状甚至文字。最后。因为显示技术的发展。我们终于可以在屏幕上显示清晰的点。叫像嘉"
   
3. 液晶显示器

4. 字符生成器

5. 屏幕缓冲区

6. 矢量命令画图

7. Sketchpad，光笔

8. 函数划线，矩形



### 0x18 The Cold War and Consumerism



### 0x19 The Personal Computer Revolution



### 0x1a Graphical User Interface



### 0x1b Internet



### 0x1c The World Wide Web



### 0x1d Cybersecurity



### 0x1e Hackers&Cyber Attacks



### 0x1f Cryptography



### 0x20 ML&AI



### 0x21 Computer Vision



### 0x22 Natural Language Processing 



### 0x23 Robots



### 0x24 Psychology Of Computing



### 0x25 Educational Technology



### 0x26 The Singularity,Skynet And The Future Of Computing

