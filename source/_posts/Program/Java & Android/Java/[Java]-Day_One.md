---
title: '[Java] Day_One'
date: 2020-07-01 11:36:35
tor: true
---

## 0x00 Preface

今天要开始学习 Java 啦!!!

书籍来源:  << Java 编程思想 >>(基于JDK 5/6,  有点太老了,  Σ( ° △ °|||)

<br>

## 0x01 Profile

> “上帝赋予人类说话的能力，而言语又创造了思想，思想是人类对宇宙的量度。 "
>
> ----摘自《Prometheus Unbound》，Shelley
>
> 人类……极其受那些已经成为社会表达工具的特定语言的支配。想像一下，如果一个人可以不使用语言就能够从本质上适应现实世界，语言仅仅是解决具体的交流和反映问题时偶尔才用到的方式，我们会发现，这只能是一种幻想。事实上，“真实世界”在很大程度上是不如不觉地基于群体的语言习惯形成的。
>
> ----摘自《The Status of Linguistics As A Science）》，1929，Edward Sapir

“真实世界”在很大程度上是不知不觉地基于群体的语言习惯形成的。

如同任何人类语言一样，Java提供了一种表达概念的方式。如果使用得当，随着问题变得更庞大更复杂，这种表达工具将会比别的可供选择的语言更为简单、灵活。

当你开始设计一个系统时，应该认识到程序开发是一种增量过程，犹如人类的学习一样，这一点很重要。程序开发依赖于实验，你可以尽己所能去分析，但当你开始执行一个项目时，你仍然无法知道所有的答案。如果将项目视作是一种有机的、进化着的生命体去培养，而不是打算像盖摩天大楼一样快速见效，就会获得更多的成功和更迅速的回馈。

为了在自己的程序中有效运用多态乃至面向对象的技术，必须扩展自己的编程视野，使其不仅包括个别类的成员和信息，而且还要包括类与类之间的共同特性以及它们之间的关系。尽管这需要极大的努力，但是这样做是非常值得的，因为它可以带来更多成效：更快的程序开发过程、更好的代码组织、更好扩展的程序以及更容易维护的代码。

 ...

## 0x02 对象

> “我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来…除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。"
>
> ----Benjamin Lee Whorf（1897 ~ 1941）



### 2.1 抽象

#### 2.1.1.  汇编语言

·    底层的轻微抽象

#### 2.1.2.  「命令式」语言

·    C、BASIC

·    对汇编的抽象

·    解决问题时

•   基于计算机的结构

•   不是基于所要解决的问题的结构

#### 2.1.3.  只针对待解决问题建模

·    世界的某些特定视图

•   LISP

•   所有问题最终都是列表

•   APL

•   所有问题都是算法形式的

•   不能解决所有问题

·    面向对象 OOP

•   表示问题空间的元素

•   不会受限于任何特定类型的问题

### 2.2.    每个对象一个接口

#### 2.2.1  类

·    问题空间的元素↔解空间的对象

#### 2.2.2.  接口

·    确定对某一特定对象，所能发出的请求

### 2.3.    每个对象都提供服务

#### 2.3.1.  把对象想象成“服务提供者”

如果我可以将问题从表象中抽取出来，那么什么样的对象可以马上解决我的问题呢？

·    开发或理解程序

·    提高「内聚性」，不试图做更多的事

## 2.4.    被隐藏的具体实现

### 2.4.1.  访		问控制

·    让客户端程序员无法触及他们不应该触及的部分

·    允许类库设计者改变内部的工作方式

### 2.4.2.  关键字

·    public

•   任何类可用

·    private

•   仅自己可访问

·    protected

•   继承的类可访问

·    default

•   同一个包可访问

## 2.5.    复用具体实现

### 2.5.1.  组合

·    现有的类→新的类

·    极大的灵活性

### 2.5.2.  继承

·    编译器→继承的类→编译时的限制

## 2.6.    继承

### 2.6.1.  基类和导出类差异

·    直接在导出类添加新方法

·    覆盖

## 2.7.    “是一个”与“像是一个”关系

### 2.7.1.  是一个

·    继承只覆盖基类

·    纯粹替代

### 2.7.2.  像是一个

·    在导出类型→新的接口元素

## 2.8.    伴随多态的可互换对象

### 2.8.1.  特定类型→基类对象

·    不依赖特定类型的代码

### 2.8.2.  函数调用

·    前期绑定

•   非面向对象编程

•   运行代码的绝对地址

·    后期绑定

•   面向对象编程

•   编译器→确保调用方法的存在

•   运行时→计算代码的地址

### 2.8.3.  Java编译器

·    how？

•   对象中存储信息→计算方法地址

·    动态绑定是默认的

•   C++需要virtual关键字

### 2.8.4.  向上转型

当向一个对象发送消息时，即使涉及向上转型，该对象也知道要执行什么样的正确行为。

·    导出类→基类

## 2.9.    单根继承结构

### 2.9.1.  好处

·    保证所有对象具有某些功能

·    极大简化参数传递

·    容易实现垃圾回收

## 2.10.  容器

如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。

### 2.10.1. 集合

·    List

•   存储序列

·    Map

•   关联数组

·    Set

•   集合

### 2.10.2. 泛型

·    向下转型：Object→具体类型

![desc](file:///C:/Users/15517/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png) 

·    参数化类型

## 2.11.  对象的创建和生命期

### 2.11.1. C++

·    追求最大的执行速度

·    编写时确定：储存空间、生命周期

·    存储

•   堆栈

•   静态存储区

### 2.11.2. Java

·    存储

•   堆的内存池

·    逻辑假设

对象趋于变得复杂，所以查找和释放存储空间的开销，不会对对象的创建造成重大冲击。

## 2.12.  异常处理：处理错误

### 2.12.1. 错误→置于编程语言中

异常是一种对象从出错地点“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”，异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一个路径。

### 2.12.2. Java内置异常处理，并强制使用

## 0x03  一切都是对象

> 如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界
>
> ----Luduing Wittgerstein（1889-1951）

**基本功:**  将思想转换到面向对象的世界中来.  即从 **指针 操作元素**变为 **对象 操作元素**. 



### 3.1. 用引用操控对象

对象可不可以理解成为物品, 而我们就是一个造物主

**[争议] :** Java 对象的标识符 和 C++的对象引用



#### 3.1.1.  遥控器（引用）→电视机（对象）

### 3.2.    必须由你创建所有对象

#### 3.2.1.  存储地点

+ 寄存器

+ 处理器的寄存器，速度最快
+ 不能直接控制
+ 堆栈
+ 通用RAM中
+ Java对象引用

·    堆

•   通用内存池

•   Java对象

·    常量存储

•   程序代码内部

•   ROM（只读存储器）

·    非RAM存储

•   流对象

•   持久化对象

#### 3.2.2.  特例：基本类型

·    boolean

·    char

·    byte

·    shor

·    int

·    long

·    float

·    double

·    void

#### 3.2.3.  高精度数字

·    BigInteger

·    BigDecimal

#### 3.2.4.  Java中的数组

·    自动初始化

·    范围检查

•   少量的内存开销

•   运行时的下标检查

### 3.3.    永远不需要销毁对象

1. 作用域和 C++ 不一样,  括号嵌套不可以有相同变量的存在(重命名),  而所谓的局部变量会一直占用空间,    .
2. Java 具有智能的垃圾回收制度,  你只管 new 对象,  我给你擦屁股,  



### 3.4.    创建新的数据类型：类

#### 3.4.1.  初始化

·    类成员的基本数据类型→初始化

·    非类字段→不初始化







### 第一个Java程序

java.lang 类会自动被导入到每一个Java文件中;

JDK: 来自Sun公司, Java Developer's Kit，Java开发人员工具包,  用来编译运行 .java 

Jlikes: 来自 IBM , 比JDK要快.  

> 每一章都有一名为build.xml的文件，该文件提供一个"ant"命令，用于自动构建该章的所有文件。Build文件和Ant（以及在哪里下载）在http:/MindView.net/Books/BetterJava所提供的补充材料中进行了完备而详细的讨论。一旦安装好Ant（可从http://jakara.apache.org/ant下载），便可直接在命令行提示符下键入ant来编译和运行每一章的程序了。如果尚未安装Ant，只要手工键入javac和java命令即可安装。



#### 名字的可见性

"名字" 间的冲突问题,  C++提供 名空间(namespace) 来解决;  Java 使用 **反转域名** 的方式 --> 确保唯一









#### Import

Java没有了 “向前引用” 的问题,  同文件夹下可以直接使用这个类, 使用 Import 导入一个类库(类, 方法和数据),  导入类



#### Static 关键字

Static字段 对 每个类 来说都只有一份存储空间;  非 Static 对 每个对象都有一份存储空间.

1. 静态字段: 类共享
2. 静态方法: 

static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。正如我们将会看到的那样，这一点对定义main0方法很重要，这个方法是运行一个应用时的入口点。和其他任何方法一样，static方法可以创建或使用与其类型相同的被命名对象，因此，static方法常常拿来做“牧羊人”的角色，负责看护与其隶属同一类型的实例群。





#### 嵌入式文档,

注释继承 C/C++ . 而嵌入式文档要求 Java 提取有用的注释信息 -- javadoc	

> javadoc 是用于提取注释的工具，是JDK安装的一部分。采用了Java编译器的某些技术，查找程序内的特殊注释标签。它不仅解析由这些标签标记的信息，也将毗邻注释的类名或方法名抽取出来。如此，我们就可以用最少的工作量，生成相当好的HTML程序文档，可以用Web浏览器查看。这样，该工具就使得我们只需创建和维护单一的源文件，并能自动生成有用的文档。有了javadoc，就有了创建文档的简明直观的标准，我们可以期望、甚至要求所有的Java类库都提供相关的文档。
>
> 此外，如果想对javadoc处理过的信息执行特殊的操作（例如，产生不同格式的输出），那么可以通过编写你自己的被称为"doclets"的javadoc处理器来实现。

**语法:** 识别 **"/\*\*"**

**使用方式:**

1. 嵌入HTML 
2. 文档标签

**Javadoc标签: **

| **标签**      |                           **描述**                           |                           **示例**                           |
| :------------ | :----------------------------------------------------------: | :----------------------------------------------------------: |
| @author       |                       标识一个类的作者                       |                     @author description                      |
| @deprecated   | 指名一个过期的类或成员; 该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性，因为在不久的将来它们很可能会被删除。如果使用一个标记为@deprecated的方法，则会引起编译器发布警告。<br/>在Java SE5中，Javadoc标签@deprecated已经被@Deprecated注解所替代（我们将在第20章中 |                   @deprecated description                    |
| {@docRoot}    | 指明当前文档根目录的路径; 产生到文档根目录的相对路径，用于文档树页面的显式超链接。 |                        Directory Path                        |
| @exception    |                     标志一个类抛出的异常                     |            @exception exception-name explanation             |
| {@inheritDoc} | 从直接父类继承的注释;从当前这个类的最直接的基类中继承相关文档到当前的文档注释中。 |      Inherits a comment from the immediate surperclass.      |
| {@link}       |                  插入一个到另一个主题的链接                  |                      {@link name text}                       |
| {@linkplain}  |     插入一个到另一个主题的链接，但是该链接显示纯文本字体     |          Inserts an in-line link to another topic.           |
| @param        | 说明一个方法的参数; 该标签用于方法文档中，可以使用任意多个这种标签，大约每个参数都有一个这样的标签。 |              @param parameter-name explanation               |
| @return       |                        说明返回值类型                        |                     @return explanation                      |
| @see          | 指定一个到另一个主题的链接; 引用其他类;  @see标签允许用户引用其他类的文档。javadoc会在其生成的HTML文件中，通过@see标签链接到其他文档。 |                         @see anchor                          |
| @serial       |                      说明一个序列化属性                      |                     @serial description                      |
| @serialData   |    说明通过writeObject( ) 和 writeExternal( )方法写的数据    |                   @serialData description                    |
| @serialField  |                说明一个ObjectStreamField组件                 |              @serialField name type description              |
| @since        | 标记当引入一个特定的变化时; 允许你指定程序代码最早使用的版本，可以在HTMLJava文档中看到它被用来指定所用的JDK版本的情况。 |                        @since release                        |
| @throws       | 和 @exception标签一样.“异常”将在第9章论述。简言之，它们是由于某个方法调用失败而“抛出”的对象。尽管在调用一个方法时；只出现一个异常对象，但是某个特殊方法可能会产生任意多个不同类型的异常，所有这些异常都需要进行说明。 | The @throws tag has the same meaning as the @exception tag.  |
| {@value}      |            显示常量的值，该常量必须是static属性。            | Displays the value of a constant, which must be a static field. |
| @version      |                         指定类的版本                         |                        @version info                         |



```java
@see classname
@see fully-qualified-classname 
@see fully-qualified-classname#method-name
//上述每种格式都会在生成的文档中加入一个具有超链接的"See Also"（参见）条目。但是javadoc不会检查你所提供的超链接是否有效。
@author author-information //如果javadoc命令行使用了-author标记，那么就从生成的HTML文档中特别提取作者信息。可以使用多个标签，以便列出所有作者，但是它们必须连续放置。全部作者信息会合并到同一段落，置于生成的HTML中。
@version version-information//可以是任何你认为适合包含在版本说明中的重要信息; 如果javadoc命令行使用了"-version"标记，那么就从生成的HTML文档中特别提取出版本信息。
@return description//其中，“description”用来描述返回值的含义，可以延续数行。
@param parameter-name description//parameter-name是方法的参数列表中的标识符，description是可延续数行的文本，终止于新的文档标签出现之前。
@throws fully-qualified-class-name description//其中fully-qualified-class-name给出一个异常类的无歧义的名字，而该异常类在别处定义。description（同样可以延续数行）告诉你为什么此特殊类型的异常会在方法调用中出现。

```

+ {@link package.classmember label}: 用于行内，并且是用"label"作为超链接文本而不用"See Also".


第一行采用我自己独特的方法，用一个作为特殊记号说明这是包含源文件名的注释行。该行包含文件的路径信息（此时，object代表本章），随后是文件名。最后一行也是一行注释，这个"ll"标志源代码清单的结束。自此，在通过编译器和执行检查后，文档就可以自动更新成本书的文本。Output标签表示输出的开始部分将由这个文件生成，通过这种形式，它会被自动地测试以验证其准确性。在本例中，（55%match）在向测试系统说明程序的每一次运行和下一次运行的输出存在着很大的差异，因此它们与这里列出的输出预期只有55%的相关性。本书中能够产生输出的大部分示例都包含这种注释方式的输出，因此你可以查看它们的运行输出，并知晓其正确性。

**编码风格:** 类名的首字母要大写，如果类名由几个单词构成，那么把它们并在一起（也就是说，不要用下划线来分隔名字），其中每个内部单词的首字母都采用大写形式。

## Afterwards

> 下面纯属我自己的废话......

+ **[重新思考许可证的作品]**  因为代码有禁止商业用途的许可证,  所以原则上书本出版社发行剖析代码的教材成为了缪事,  所以有了之前我找遍书籍都没有的存在,  一部分情况下,  这无异于在技术的传播的大动脉切了一刀,  这会是致命的,  这是一个角度,  可能现在你我都太自私了,  但是资本主义就是这样让人窒息的存在;  另一个角度,  如果别人用我的代码获利,  这也当然不可以,  所以这是矛盾对立的两个方面.



