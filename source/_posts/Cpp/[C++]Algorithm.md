---
title: '[C++] Algorithm'
date: 2020‎-0‎1‎-0‎1-30‎ ‎20:42:39
toc: true
---
</br>
> 学习数据结构和算法其实是明白数据的存储结构和操作逻辑，然后更好的去实现代码的编辑。

</br>

## 0x01 Notes

首先需要了解一下函数原型：

查了一下维基百科和别人的一些笔记：

函数原型( **Function prototype** ) 或**函数接口**（**Function interface**）是用于**指定函数的名称和类型特征**（元数，参数的数据类型和返回值类型）的一种省略了函数体的函数声明。虽然函数声明规定了函数是如何被实现的，但仅包括对接口的定义（即接受的数据类型和返回的数据类型），并不包括对函数体的定义。
函数原型被广泛应用于C、C++ 语言程序代码的上下文中，**通过在头文件中放置函数的前向声明来允许将代码拆分为多个翻译单元**。即**编译器可以单独编译目标文件的这部分内容,然后由链接器组合成可执行文件或库**。现代编译器（如Arduino IDE）不再需要函数原型，因为这些是在编译时确定和声明的。
在原型中，参数名是可选的（C/C++中存在函数原型作用域，这使参数名的作用域被限制在函数定义内），但是，类型和修饰符都是必需的（如指针或常量参数）。

</br>

### 1.1 排序优化

相信看完基本对算法书里的函数原型有点了解了吧。然后看一个从[·](https://www.cnblogs.com/laizhenghong2012/p/8442270.html)引用来的一C语言的个例子（C语言内置的qsort函数）

```c
#include <stdio.h>      /* printf */
#include <stdlib.h>     /* qsort */
int values[] = { 40, 10, 100, 90, 20, 25 };
int compare(const void* a, const void* b){
	return (*(int*)a - *(int*)b);
}
int main(){
	int n;
	qsort(values, 6, sizeof(int), compare);
	for (n = 0; n < 6; n++) printf("%d ", values[n]);
	return 0;
}
```

 注意：

1. **函数原型** 

   ```c
   void qsort(
       void *base,//指向数组的起始地址，通常该位置传入的是一个数组名
       size_t nmemb,//表示该数组的元素个数
       size_t size,//表示该数组中每个元素的大小（字节数）
       int (*compar)(const void *, const void *)//此为指向比较函数的函数指针，决定了排序的顺序。（作为回调函数使用	）
   );
   ```

   <font color="red"> 如果两个元素的值是相同的，那么它们的前后顺序是不确定的。也就是说qsort()是一个不稳定的排序算法。 </font>

2. 上述中的决定排序顺序的比较函数: **compar**参数指向一个比较两个元素的函数。 在compar函数内部会将const void *型转换成实际类型
   `int compar(const void *p1, const void *p2);` 
   如果compar返回值小于0（< 0），那么p1所指向元素会被排在前面
   如果compar返回值等于0（= 0），那么p1指向元素与p2指向元素的顺序**不确定**
   如果compar返回值大于0（> 0），那么p2所指向元素会被排在前面
   **也就是说默认是升序序列**，换序直接作用于比较函数即可。

3. 回调函数：（函数的多层叠加） 通过函数指针调用的函数。 如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。

竞赛中的排序有三种：分别是C库的qsort，C++库的sort（第一种是传入一个 functor 对象，另外一种是直接传入一个排序函数），经过下面代码的运行

```c++
using namespace std;
#define _for(i,a,b) for(int i=(a);i<(b);++i)
const int N = 10000000;
struct TS {
	int a, b, c;
};
inline bool cmp(const TS& t1, const TS&t2) {
	if (t1.a != t2.a)return t1.a < t2.a;
	if (t1.b != t2.b)return t1.b < t2.b;
	return t1.c < t2.c;
}
int cmp4qsort(const void* a, const void* b) {
	TS* t1 = (TS*)a, * t2 = (TS*)b;
	if (t1->a != t2->a)return t1->a - t2->a;
	if (t1->b != t2->b)return t1->b - t2->b;
	return t1->c - t2->c;
}
struct cmpFunctor {
	inline bool operator()(const TS& t1, const TS& t2) {
		if (t1.a != t2.a)return t1.a < t2.a;
		if (t1.b != t2.b)return t1.b < t2.b;
		return t1.c < t2.c;
	}
};
TS tss[N];
void genData() {
	_for(i, 0, N) {
		tss[i].a = rand();
		tss[i].b = rand();
		tss[i].c = rand();
	}
}
int main() {
	srand(time(NULL));

	genData();
	clock_t start = clock();
	sort(tss, tss + N, cmp);
	printf("sort by functor pointer: %ld\n", clock() - start);

	genData();
	start = clock();
	sort(tss, tss + N, cmpFunctor());
	printf("sort by functor: %ld\n", clock() - start);

	genData();
	start = clock();
	qsort(tss, N, sizeof(TS), cmp4qsort);
	printf("qsort by functor pointer: %ld\n", clock() - start);

	return 0;
}
```

运行结果
`sort by functor pointer: 27337（36732）（C 5515）(D 3200)
sort by functor: 25326（6324）（C 3408）(D 3106)
qsort by functor pointer: 9481（15996）（C 3071）(D 2884)`

不知道为什么和作者的测试效果不一样，我的这个编译器（VS2019）测出来qsort是最快的，这点值得商榷。传入排序函数是最慢的这一点是相同的。已经有点混乱了，程序应该是没有问题的呀？和作者测试的不一样，这里先存疑吧？？？

---

笔者的机器上测试发现，STL 的 sort 使用 functor 的版本是最快的，比 qsort 都快一倍多。而使用 sort 传入函数指针的版本速度是最慢的，相对于前两者有大约 6 倍和 3 倍的差距，会在一些对排序性能要求很高的题目中形成比较明显的瓶颈，提醒读者注意。

---





### 1.2  万能头文件

```cpp
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdalign>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif
```

</br>

</br>

</br>

## 0x02 实操经验

### 2.1 读取字符串的系列操作

这里笔者搞错了一个数组的概念……自愧弗如，数组是申请一段连续的内存，`a[10]`申请到的内存是`a[0]`到`a[9]`，是没有`a[10]`的，这里下标就是一个误区，因为以前总是喜欢数组开1000，所以根本没有时注意这点。

也就是说，如何你要读取11位的数字（手机号码），你要开的内存大小最少是12`p[12]`，读取也是12`cin.getline(p,12)`，不存在说p[12]和p[11]都是空的疑问…………

#### 2.1.1 读取字符串的操作细节

```c++
int main() {	
	char p[5];
	cin.getline(p, 5);//准确来说读取的位数是4位+'\0'一共五位，四位有效数字
	cout << p << endl;
}
```

如注释所言，这样控制的数量只可以是读取有效的四位而已，如果要读取五位数字，就要定义6大小的数组。

#### 2.2 字符数组整体命名的细节

```c++
int main() {
	char w[5] = { 'Dang' };
	cout << w<<"\n";
	char p[] = { "Dang" };
	cout << p;
}
```

注意的一点就是要用双引号（单引号会变成那个串的最后一个字母!!!枯了）

#### 2.3 不确定数组的大小

字符数组那自不必我多说是用`strlen(p)`来确定，但是同样的，可以用`sizeof(p)/sizeof(char)`来确定

### 2.2 新的循环

```c++
int main() {
	int array[] = { 1,2,3,4,5,'\0' };
	for (int i : array)i *= 2;
	for (int i = 0; array[i] != '\0'; i++)cout << array[i] << " ";
	cout << endl;
	for (int &i : array)i *= 2;
	for (int i = 0; array[i] != '\0'; i++)cout << array[i] << " ";
}
```

 这里的运行结果是：

`1 2 3 4 5`
		`2 4 6 8 10`

---

这个循环大有来历，当初问老师老师也不承认这是C++的标准写法，但是整洁度还是让我比较向往这样的写法。

自己仿照这个循环自己写了一个小小的循环，这个循环叫foreach循环，是从Java引用过来的？！**是C++11的新特点**。其实还是有点懵逼

```c++
void printLOVE() {
	char arr[] = { 'I','O','E','V','L',' ','U','Y','O'};
	int index[] = { 0,5,4,1,3,2,5,7,8,6 };
	for (int i : index) {
		cout << arr[i];
	}
}
```

把数组 a中所有的数，一一 赋给 b,并且 每赋值一个数 执行{}中的 代码一次 

### 2.3 两个冒号的操作

一个冒号有这样的特点，那你能说出**两个冒号的特点吗**？

1.  全局作用域符号
   当全局变量在局部函数中与其中某个变量重名时，可以用::来区分，否则局部变量会屏蔽全局变量。

   ```c++
   int a = 10;
   int main() {
   	int a = 100;
   	cout << a << endl;
   	cout << ::a;
   }
   ```

2. 作用域符号 
   前面一般是该类名称，后面是该类的成员名称。C++为避免不同的类有相同的成员而采用作用域的方式进行区分，eg：A，B表示两个类，在A，B中都有成员member，那么：A::member表示A中的成员member，B::member表示B中的成员member。 

3.   作用域分解运算符 

   比如声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f函数的定义，那么在类外定义f时，就要写成void A::f()，表示这个f函数是类A的成员函数。 

### 2.4 OVERFLOW 

​	查到的一点是：stack overflow和CSS里面的overflow属性，还是比较懵逼，自己`cout<<OVERFLOW;`结果是3，也不清楚是什么，留存在这里。

 OVERFLOW为math.h中的一个[宏定义](https://www.baidu.com/s?wd=宏定义&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，其值为3。含义为运算过程中出现了上溢，即运算结果超出了运算变量所能存储的范围。 

### 2.5 exit和return的区别

附上度娘的[链接](https://baike.baidu.com/item/Exit%28%29/1883141)

1. exit用于在程序运行的过程中随时结束程序，exit的参数是返回给OS的。main函数结束时也会隐式地调用exit函数。exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。exit是结束一个进程，它将删除进程使用的内存空间，同时把错误信息返回父进程,而return是返回函数值并退出函数 

2. return是**语言级别**的，它表示了**调用堆栈**的返回；而exit是**系统调用**级别的，它**表示了一个进程的结束**。
   按照ANSI C，在最初调用的main()中使用return和exit()的效果相同。 但要注意这里所说的是“**最初调用**”。**如果main()在一个递归程序中，exit()仍然会终止程序；但return将控制权移交给递归的前一级，直到最初的那一级，此时return才会终止程序**。return和exit()的另一个区别在于，**即使在除main()之外的函数中调用exit()，它也将终止程序。**
3. exit函数是退出应用程序，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息。

4. 和机器和操作系统有关一般是  0 为正常退出 非0 为非正常退出



### 2.6  全局数组大小

> 全局数组到底可以开多大？为什么局部数组就不可以开大？

**[原理]：**涉及C语言的内存分配问题，C语言占用的内存可以分为5个区：

> 1. **代码区（Text Segment）**：用于放置编译过后的代码的二进制机器码。

<br/>

> 2. **堆区（Heap）**
>
> **特点**：first in first out，fifo。
>
> **地址空间** ：“向上增加” ，即保存的数据越多，堆的地址就越高。
>
> **功能：**用于动态内存分配。由程序员分配和释放，若不释放，当结束程序时可能由OS回收。而长时间不释放易导致“内存泄漏”。（其实就是malloc()函数能够掌控的内存区域）
>
> **注：**和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。 32位以上的操作系统支持“虚存”.

<br/>

>
>   3. **栈区（Stack）**
>
> **特点**：向低地址扩展的数据结构，是一块连续的内存的区域。即**栈顶的地址**（在可读写的ram区的最后。是为执行线程留出的内存空间）和**栈的最大容量**是**系统预先规定**好的。last in first out，lifo。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它的信息。栈另外一个重要的特征是，它的
>
> **地址空间：**“向下减少”，即当栈上保存的数据越多，栈的地址就越低。
>
>**功能：**一般用来存放局部变量、函数参数，由编译器自动分配和释放。
>
>**性质：**附属于**线程**，当线程结束时栈被回收。
>
> **场景：**   函数被调用的时候，栈顶为局部变量和一些 bookkeeping 数据预留块。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出（LIFO）的方式预留空间；因此最近的保留块（reserved block）通常最先被释放。这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。
>
> **注：**   16位模式下有段的概念,一个段只有64K。所以任何连续数据都不能超过这个尺寸。
>

<br/>

>   4. **全局初始化数据区/静态数据区（Data Segment）**
>   
>**功能：**存放**全局变量和静态变量**。初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
> 
>**特点：**这个区域被整个进程共享。

<br/>

>   5. **未初始化数据区（BSS,block started by symbol）**
>
> **特点：**初始化值得时候全局变量和静态变量待的地方，运行时改变值的同时根据自身属性进入上面的区域
>
> **注：**数组在局部初始化的时候会赋予随机数（乱码），但是变量不会，如果没有没定义多大就会显示类似`Not limited`的错误。**常量字符串就是放在这里的。 程序结束后由系统释放** 

<br/>

总之。研究这个意义不大，不同编译器，可能行为不同。在Windows下，Data Segment（静态数据区）的所允许的空间大小取决于剩余内存的大小，也就是说，如果电脑剩余8G内存的话，int类型的二维数组甚至可以开到`46340*46340`的大小； 而 Stack（栈区）的空间只有<font color="red">2M！(这里我在用VS编译的时候好像是VS自定义了一个比2M小得多的栈区，经过蛋疼测试，极限是`int p[258298]``258298*4/1024/1024=0.98532M`大小，大概是1M的大小，可以用连接器参数`/STACK:reserve[,commit]`调整栈大小)</font>也就是 `2*1024*1024=2097152字节`，局部变量空间顶多放得下下524288个int类型（数组大概是`724.077*724.077`）！知道上述几个关键后，一开始的问题就不是问题了。但我想在局部中开一个大数组怎么办？很简单，将它归到Data Segment中：

```cpp
#include<iostream>
using namespace std;
int main(){
    static int dis[8000][8000];//注意局部变量的初始化
}
```

而在局部定义数组的时候，数组会自动初始化为随机数，所以数组在刚被定义的时候就塞进Stack区了，才会出现int dis[520073]直接报堆栈溢出的问题。如果需要大量的内存.建议使用new在堆上创建对象().或者直接使用windowsAPI VirtualAlloc,GlobalAlloc等自己从系统堆上分配.（自己暂时还不明白……）

引用他人写的cpp：

```cpp
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
int main() { 
	int b; //栈 
	char s[] = "abc"; //栈 
	char *p2; //栈 
	char *p3 = "123456"; //123456在常量区，p3在栈上。 
	static int c =0； //全局（静态）初始化区 
	p1 = (char *)malloc(10); 
	p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 
    strcpy(p1, "123456"); //123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
}
```

<br/>

这里主要区别对比一下堆和栈：

1. 申请机制：
   **栈**：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

   **堆**：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 
   会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

2. 大小限制 ：

   **栈**：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在  WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 

   **堆**：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

3. 效率比较：
   **栈**由系统自动分配，速度较快。但程序员是无法控制的。 

   **堆**是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 
   另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度， 也最灵活 

4. 存储内容 
   **栈**： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 
   当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
**堆**：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 
   
5. 每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。

   

   <br/><br/>

效率比较实例：

```cpp
char s1[] = "aaaaaaaaaaaaaaa"; //aaaaaaaaaaa是在运行时刻赋值的； 
char *s2 = "bbbbbbbbbbbbbbbbb"; //bbbbbbbbbbb是在编译时就确定的； 
```

在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 这个可以用编译后的汇编代码查看操作来敲定到底做了什么。（Flag）



<font color="red">**理性分析：**</font>

回归这道题目，具体开多大根据题目给的内存进行处理，如：`8000*8000*4/1024/1024≈244 MB`.`8192*8192*4/1024/1024≈256 MB`.普通题目最大可以开到8129的大小。考虑要用到的局部变量的话，一个局部变量是`1*4/1024/1024=0.0000038MB`,相对而言比较大的局部变量是他的二倍，不过`0.0000076MB`.明显占不到什么内存。







### 2.7 运算符的优先顺序

之前写了一个程序

```cpp
int main() {
	int a, b, c;
	a = 1, b = 0, c = 1;
	if (a == b == c==0) cout << "Y";
    cout<<endl;
    a = 1, b = 1, c = 1;
	if (a == b == c==0) cout << "Y";
}
```

居然给我输出`Y`……

```cpp
Y

```

于是上网找了找资料……涉及到了运算符的结合顺序，

> 先执行a`==`b结果是（true或false）再和c比。那么c的`==`是和a`==`b的结果进行比较而已。

所以自己从左面一步一步算到右面居然就是正确的……以下附上C++运算符优先级以及结合表，以前都没有这么注意过这个……：

| 优先级 |   运算符   |      名称或含义       |         使用形式          | 结合方向 |          说明          |
| :----: | :--------: | :-------------------: | :-----------------------: | :------: | :--------------------: |
|   1    |     []     |       数组下标        |    数组名[常量表达式]     |  左到右  |                        |
|        |     ()     |        圆括号         | (表达式)  函数名(形参表)  |          | 函数调用<br />参数传递 |
|        |     .      |   成员选择（对象）    |        对象.成员名        |          |                        |
|        |     ->     | 成员指针选择（指针）  |     对象指针->成员名      |          |                        |
|        |     .*     |     成员指针选择      |                           |          |                        |
|        |    ->*     |     成员指针选择      |                           |          |                        |
|   2    |     -      |      负号运算符       |          -表达式          |  右到左  |       单目运算符       |
|        |   (类型)   |     强制类型转换      |     (数据类型)表达式      |          |                        |
|        |     ++     |      自增运算符       |    ++变量名  变量名++     |          |       单目运算符       |
|        |     --     |      自减运算符       |    --变量名  变量名--     |          |       单目运算符       |
|        |     *      |      取值运算符       |         *指针变量         |          |       单目运算符       |
|        |     &      |     取地址运算符      |          &变量名          |          |       单目运算符       |
|        |     !      |     逻辑非运算符      |          !表达式          |          |       单目运算符       |
|        |     ~      |    按位取反运算符     |          ~表达式          |          |       单目运算符       |
|        |   sizeof   |      长度运算符       |      sizeof(表达式)       |          |                        |
|        | new delect | 动态内存分配 释放内存 |                           |          |                        |
|   3    |     /      |          除           |      表达式 / 表达式      |  左到右  |       双目运算符       |
|        |     *      |          乘           |       表达式*表达式       |          |       双目运算符       |
|        |     %      |     余数（取模）      |   整型表达式%整型表达式   |          |       双目运算符       |
|   4    |     +      |          加           |       表达式+表达式       |  左到右  |       双目运算符       |
|        |     -      |          减           |       表达式-表达式       |          |       双目运算符       |
|   5    |     <<     |         左移          |       变量<<表达式        |  左到右  |       双目运算符       |
|        |     >>     |         右移          |       变量>>表达式        |          |       双目运算符       |
|   6    |     >      |         大于          |       表达式>表达式       |  左到右  |       双目运算符       |
|        |     >=     |       大于等于        |      表达式>=表达式       |          |       双目运算符       |
|        |     <      |         小于          |       表达式<表达式       |          |       双目运算符       |
|        |     <=     |       小于等于        |      表达式<=表达式       |          |       双目运算符       |
|   7    |     ==     |         等于          |      表达式==表达式       |  左到右  |       双目运算符       |
|        |     !=     |        不等于         |      表达式!= 表达式      |          |       双目运算符       |
|   8    |     &      |        按位与         |       表达式&表达式       |  左到右  |       双目运算符       |
|   9    |     ^      |       按位异或        |       表达式^表达式       |  左到右  |       双目运算符       |
|   10   |     \|     |        按位或         |      表达式\|表达式       |  左到右  |       双目运算符       |
|   11   |     &&     |        逻辑与         |      表达式&&表达式       |  左到右  |       双目运算符       |
|   12   |    \|\|    |        逻辑或         |     表达式\|\|表达式      |  左到右  |       双目运算符       |
|   13   |     ?:     |      条件运算符       | 表达式1? 表达式2: 表达式3 |  右到左  |       三目运算符       |
|   14   |     =      |      赋值运算符       |        变量=表达式        |  右到左  |                        |
|        |     /=     |       除后赋值        |       变量/=表达式        |          |                        |
|        |     *=     |       乘后赋值        |       变量*=表达式        |          |                        |
|        |     %=     |      取模后赋值       |       变量%=表达式        |          |                        |
|        |     +=     |       加后赋值        |       变量+=表达式        |          |                        |
|        |     -=     |       减后赋值        |       变量-=表达式        |          |                        |
|        |    <<=     |      左移后赋值       |       变量<<=表达式       |          |                        |
|        |    >>=     |      右移后赋值       |       变量>>=表达式       |          |                        |
|        |     &=     |     按位与后赋值      |       变量&=表达式        |          |                        |
|        |     ^=     |    按位异或后赋值     |       变量^=表达式        |          |                        |
|        |    \|=     |     按位或后赋值      |       变量\|=表达式       |          |                        |
|   15   |     ,      |      逗号运算符       |      表达式,表达式,…      |  左到右  |                        |

下表就整理了优先级同为1 的几种运算符如果同时出现的情况：

| 优先级问题                                    | 表达式                 | 经常误认为的结果                                         | 实际结果                                                     |
| :---------------------------------------------: | :----------------------: | :--------------------------------------------------------: | :------------------------------------------------------------: |
| . 的优先级高于 *（-> 操作符用于消除这个问题） | `*p.f`                 | p 所指对象的字段 f，等价于：  (*p).f                     | 对 p 取 f 偏移，作为指针，然后进行解除引用操作，等价于：  *(p.f) |
| [] 高于 *                                     | `int *ap[]`            | ap 是个指向 int 数组的指针，等价于：  int (*ap)[]        | ap 是个元素为 int 指针的数组，等价于：  int *(ap [])         |
| 函数 () 高于 *                                | `int *fp()`            | fp 是个函数指针，所指函数返回 int，等价于：  int (*fp)() | fp 是个函数，返回 int*，等价于：  int* ( fp() )              |
| == 和 != 高于位操作                           | `(val & mask != 0)`    | (val &mask) != 0                                         | val & (mask != 0)                                            |
| == 和 != 高于赋值符                           | `c = getchar() != EOF` | (c = getchar()) != EOF                                   | c = (getchar() != EOF)                                       |
| 算术运算符高于位移 运算符                     | `msb << 4 + lsb`       | (msb << 4) + lsb                                         | msb << (4 + lsb)                                             |
| 逗号运算符在所有运 算符中优先级最低           | `i = 1, 2`             | i = (1,2)                                                | (i = 1), 2                                                   |

### 2.8 结构体下嵌套表达式错位

写一个程序如此这般

```cpp
typedef struct Stu {
	char id;
	string name;
}S;
int main() {
	int N, k, i = 0;
	cin >> N, k = N;
	S* p = new S[N];
	while (k--) cin >> p[i].id >> p[i++].name;
	for (i = 0; i < N; i++) {
		cout << p[i].id << " " << p[i].name << endl;
	}
//  ......
}
/*
程序写了一半
3
1 zhangsan
2 lisi
3 wangwu
*/
```

测试一下发现不对，在我的VS2019中测试结果是：

```cpp
?zhangsan
1 lisi
2 wangwu
```

有点懵逼，请教完师傅后明白了，是c++中如果函数的参数列表包含多个实参，那么对参数的求值顺序是不确定的。即编译器对函数的嵌套表达式求值方向是不一样的，即使是同一个编译器在不同情况下也会不一样，而且在每一次变换的情况下最终结构也大相径庭，所以在实际使用中，要尽量避免一个语句中包含多个表达式的情况，或者保证多个表达式之间不存在互相影响结果的情况。

> cin其实是个写法特殊的函数，`pi.id`和`pi.name`其实是它的两个参数，c++参数求值顺序不确定，例如 f(a,a++);假设a的值为10，如果先左后右 就是10、10 ，然后a变11，如果先右后左 就是11、10。这一点c++标准里没规定，所以不同厂商的编译器在处理库函数和自定义函数时处理方法各异，解决办法为：涉及到函数调用实参间时，避免使用。

博主测试代码（转）：

```cpp
void test(int x, int y) {
	cout << 'x' << x << " y" << y << endl;
}
int main() {
	int i = 3;
	test(i, i++);
	i = 3, test(i, ++i);
	i = 3, test(i++, i);
	i = 3, test(++i, i);
}
```

最终结果：

```cpp
x4 y3
x4 y4
x3 y4
x4 y4
```







## 0x03 优化写法

char数组写的时候一定要记住最后的'\0'，因为他的后面可能是随机数，也可能全是0，好点的编译器会给你加\0,但是不要侥幸。

dec的用处就是1在其他编译器里去转换。

逻辑结构的背后是逻辑电路，正如逻辑语言背后是逻辑内存

遇到有限制条件的题在进行循环的时候将限制条件放在第一位（如题1128）——逻辑短路

读取EOF的意思：while(scanf("%d %d     %d",&m,&n,&t)!=EOF&&(n&&m&&t)) 





### 3.1 Define

1. 多语句的宏定义可以写成：

```cpp
#define swap(x, y)\
x = x + y;\
y = x - y;\
x = x - y;
```

​	int size = sizeof(a) / sizeof(int);是否有必要??????

```cpp

char p[10];
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++)cin>>p[i];
	cout<<strlen(p)<<endl;
	int size=sizeof(p)/sizeof(char);
	cout<<size<<endl;
} 
```





## 0x04 Error

| Section              | What |
| -------------------- | ---- |
| Accepted | 你的程序对所有的测试数据都输出了正确的答案，你已经得到了该题的所有分数，恭喜。 |
|Wrong Answer|评判系统测试到你的程序对若干组（或者全部）测试数据没有输出正确的结果。<br />出现该种错误后，一般有两种解决方向：<br />1. 如果对设计的算法正确性有较大的把握，那么你可以**重点考虑代码健壮性**，即是否存在某些特殊数据使程序出现错误，比如边界数据，比如程序中变量出现溢出。<br />2. 即怀疑算法本身的正确性，那么你就需要重新考虑你的算法设计了。|
|Presentation Error|评判系统认为你的程序输出“好像”是正确的，只是没有严格按照题目当中输出所要求的输出格式来输出你的答案，例如你忽略了题目要求在每组输出后再输出一个空行。<br/>出现这种错误，往往预示着你离完全正确已经不远了，出现错误似乎只是因为**多输出了一些空格、换行之类的多余字待而已**。但这**不是绝对**的，假如在排版题中出现格式错误，那么有可能你离正确的答案仍然有一定的距离。|
|Time Limit Exceeded|你的程序在输出所有需要输出的答案之前已经超过了题目中所规定的时间。<br/>若这种结果出现在你的评判结果里，依然有两种方向可供参考：<br />1. 假如你确定算法时间复杂度能够符合题目的要求，那么依旧可以检查是否程序**可能在某种情况下出现死循环**，**是否有边界数据**可能会让你的代码不按照预想的工作，从而使程序不能正常的结束。<br />2.你设计的**算法时间复杂度**是否已经离于题目对复杂度的要求，如果是这样，那么你需要重新设计更加高效的算法或者对你现行的算法进行一定的优化。|
|Runtime Error|你的程序在计算答案的过程中由于出现了某种致命的原因异常终止。你可以考虑以下几个要点来排除该错误：<br />1. 程序是否**访问了不该访问的内存地址**，比如访问**数组下标越界**。<br />2.程序是否出现了**除以整数0**，从而使程序异常。<br />3.程序**是否调用了评判系统禁止调用的函数**。<br />4.程序是否会出现**因为递归过深或其他原因造成的栈溢出**。|
|Compile Error|你提交的程序并没有通过评判系统的编译，可根据更详细的编译信息修改你的程序。|
|Memory Limit Exceeded|你提交的程序在运行输出所有的答案之前所调用的内存已经超过了题目中所限定的内存限制。造成这种错误的原因主要有两个方面：<br />1.你的程序**申请过多的内存**来完成所要求的工作，即**算法空间复杂度**过高。<br />2.因为**程序本身的某种错误使得程序不断的申请内存**，例如因为某种原因出现了**死循环，使得队列中不断的被放入元素**。当然也千万别忽略自己的低级错误，比如**在声明数组大小时多打了一个0**。|
|Output Limit Exceeded|你的程序**输出了过多的东西，甚至超出了评判系统为了自我保护而设定的被评判程序输出大小的最高上限**。一般来说该种错误并不常见，一旦出现了也很好找原因。<br />1. 要么就是你在提交时忘记关闭你在调试时输出的调试信息（我经常输出DP时的数组来动态的观察状态的转）<br />2.要么就是程序的输出部分出现了死循环，使得程序不断地输出而超出系统的限制。|
||其实还有一种错误就是你容易把其中的一些字符给打错这样子|


## 参考资料：

[1]. [关于C语言开大数组溢出的问题](https://blog.csdn.net/qq_21882325/article/details/65445810).Leaviathan

[2]. [局部变量，静态局部变量，全局变量，静态全局变量在内存中的存放区别(转)](https://www.cnblogs.com/bakari/archive/2012/08/05/2623637.html).Linux云计算网络

[3]. C++ 基础理论来自《C++ Primer Plus 中文（第六版）》

[4]. 算法与数据结构部分来自《算法竞赛入门经典第三册——习题与解答》

[5]. [c++中函数参数的求值顺序](https://www.cnblogs.com/Leon-Yan/p/7567766.html). Leon_Yan

[6].[[C/C++板块推荐阅读] 关于C,C++表达式求值顺序.]( https://bbs.csdn.net/topics/370153775) . 裘宗燕

[7].  [C++的数组可以int n;cin>>n;int a`n;`这样初始化吗](https://segmentfault.com/q/1010000006672117).

[8]. [C++ Style and Technique FAQ  （中文版）](http://www.stroustrup.com/bstechfaq.htm).

[9]. **[Bjarne Stroustrup](http://www.research.att.com/~bs/homepage.html) 的 C++ 风格与技术 [FAQ](www.stroustrup.com/bsfaq2cn.html)（中文版）**

