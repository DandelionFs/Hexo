---
title : '[C++] Volume One'
date : 2020-01-15 10:21:21
toc: true
---
<center><font size=2 color=grey>CD:2020-01-15 10:21:21</font></center>
</br>

### 0x00 Proface

理论在这里，实现在后面

#### Birth

在Bjarne博士等人试图去分析UNIX的内核的时候(1979.04)，当时由于没有合适的工具能够有效的**分析由于内核分布而造成的网络流量**，以及怎样将内核模块化。

同年10月，Bjarne博士完成了一个可以运行的预处理程序，称之为Cpre，它为C加上了类似Simula的类机制。在这个过程中，Bjarne博士开始思考是不是要开发一种新的语言，当时贝尔实验室对这个想法很感兴趣，就让Bjarne博士等人组成一个开发小组，专门进行研究。

当时不是叫做C++，而是C with class，这是把它当作一种C语言的有效扩充。由于当时C语言在编程界居于老大的地位，要想发展一种新的语言，最强大的竞争对手就是C语言，所以当时有两个问题最受关注：

1. C++要在运行时间、代码紧凑性和数据紧凑性方面能够与C语言相媲美

2. 尽量避免在语言应用领域的限制。

在这种情况下，一个很自然的想法就是让C++从C语言继承过来，但是我们的**Bjarne为了避免受到C语言的局限性，参考了很多的语言，例如：从Simula继承了类的概念，从Algol68继承了运算符重载、引用以及在任何地方声明变量的能力，从BCPL获得了//注释，从Ada得到了模板、名字空间，从Ada、Clu和ML取来了异常**。下图是C++标准的上个世纪的历史：

![](http://m.qpic.cn/psc?/V13aSAY12tLYCN/NrBG0KpF3EQEf3NYGEmEN*H.YIN8jHeb6sBXCnj7XDv.Wbnk3lZpZLUVayybksTq14q9jJKdSanFvXsVYNXn3Q!!/b&bo=kS9DAwAAAAADB9w!&rf=viewer_4&t=5)

作为Linux源码的C从B语言发展而来……

拓展阅读：[知乎](https://www.zhihu.com/question/22826568/answer/318102471)

</br>

</br>

### 0x01 C++

```c++
#include<cstdio>//头文件(.h) stdio代表standard input/output，也就是标准输入输出的意思(对键盘输入输出的支持)
#include<iostream>
using namespace std;
int main(void){// 圆括号（）表明main是一个函数，void表明main 函数不接受任何参数 int main(void)是ISO/ANSI C标准中定义的 main 函数定义方法之一
	cout<<"hello world!";
	return 0;
}// { 标志着函数体开始。函数体以闭大括弧 } 结束
```

**ISO/[ANSI C](https://baike.baidu.com/item/ANSI%20C/7657277)**

> ANSI C是由美国国家标准协会（ANSI）及国际标准化组织（ISO）推出的关于C语言的标准。ANSI C 主要标准化了现存的实现， 同时增加了一些来自 C++ 的内容 （主要是函数原型） 并支持多国字符集 （包括备受争议的三字符序列）。 ANSI C 标准同时规定了 C 运行期库例程的标准。

2. 头文件：包含着编译器进行编译时所需的信息。可能指明了函数名和函数调用方法，但是这些函数的**实现代码**在**预先编译**好了的**库文件**里。
3. **链接器**负责在库文件中寻找我们的程序所需的代码，并且把那些代码和我们写的程序进行链接，从而将我的写的程序**链接成可执行文件**。一句话，头文件用于指导编译器正确地将我们写的源程序编译成可执行文件。

</br>

---

**main函数**

误区：**void main()** [4]

> C/C++ 中从来没有定义过**void main( )** 。**C++** 之父 **Bjarne Stroustrup** 在他的主页上的 **FAQ** 中明确地写着：
>
> The definition void main( ) { /* ... */ } is not and never has been C++, nor has it even been C.（ void main( ) 从来就不存在于 C++ 或者 C ）

在 **C89** 中，**main( )** 是可以接受的。**Brian W. Kernighan** 和 **Dennis M. Ritchie** 的经典巨著 The C programming Language 2e（《C 程序设计语言第二版》）用的就是 main( )。

**C98**中定义了如下两种 main 函数的定义方式：

```c++
int main( )//等同于上
int main( int argc, char *argv[] )
```

**C99** 标准中，只有以下两种定义方式是正确的：

```cpp
int main( void )//不需要从命令行中获取参数
int main( int argc, char *argv[] )//和上面的需求相反
```

 当然，``char *argv[]` 可以写成`char **argv`；

如果 main 函数的最后没有写 `return` 语句的话，

注意：

+ C99 规定编译器要自动在生成的目标文件中（如 exe 文件）加入return 0; ，表示程序正常退出。
+ VC6(1998年)不会在目标文件中加入`return 0`；gcc3.2（Linux 下的 C 编译器）会在生成的目标文件中加入 return 0。

* main 函数的返回值应该定义为 int 类型，C 和 C++ 标准中都是这样规定的。虽然在一些编译器中，void main 可以通过编译（如 vc6），但并非所有编译器都支持 void main ，因为<font color="red">**标准中从来没有定义过** **void main** 。**g++3.2 中如果 main 函数的返回值不是 int** **类型，就根本通不过编译**</font>。而 gcc3.2 则会发出警告。所以，如果你想你的程序拥有很好的**可移植性**，请一定要用 int main 。(原来markdown的颜色设置可以用英文来代替，是可以说是很方便的)。

</br>

---

**返回值**

**main 函数的返回值**用于说明程序的退出状态。如果返回 0，则代表程序正常退出；返回非零(具体由系统决定)代表程序异常退出。

> [小实验] 在CMD里运行刚才编译好的exe，然后输入“echo **%ERRORLEVEL%**”，回车，就可以看到程序的返回值为 0 。
>
> 假设刚才编译好的文件是 a.exe ，如果输入“**a && dir**”，则会列出当前目录下的文件夹和文件。
>
> 但是如果改成“return -1”，或者别的非 0 值，重新编译后输入“a && dir”，则 dir 不会执行。
>
> 如果你闲，可以把 main 函数的返回值类型改成非 int 类型（如 float），重新编译后执行“a && dir”，看看会出现什么情况，想想为什么会出现那样的情况。顺便提一下，如果输入 **a || dir** 的话，则表示如果 a 异常退出，则执行 dir。

**表示了：**如果 && 前面的程序正常退出，则继续执行 && 后面的程序，否则不执行。也就是说，利**用程序的返回值，我们可以控制要不要执行下一个程序**。这就是 int main 的好处。



* 编译器也可以提供main()的更多重载版本，不过它们都必须返回int，这个int是返回给你的程序的调用者的，这是种“负责”的做法，“什么都不返回”可不大好哦。如果你程序的调用者不支持用“返回值”来交流，这个值会被自动忽略——但这也不能使void
  main()成为合法的C++或C代码。即使你的编译器支持这种定义，最好也不要养成这种习惯——否则你可能被其他C/C++程序员认为浅薄无知哦。
* 另外，还要请你注意：无论是ISO C++还是C99都不允许你省略返回类型。这也就是说，和C89及ARM C++[译注：指Margaret Ellis和Bjarne Stroustrup于1990年合著的《The Annotated C++ Reference Manual》中描述的C++]不同，int并不是缺省返回值类型。

</br>

---

**注释**

* C99 之前的注释只是“*” ，C89之后加入//（**VC6** 支持 //，**TC2** 不支持）

</br>

---

**空间**

  C95之前都是全局空间，C99后加入名空间

</br>

---

**申明的位置**

C99之后支持在任何地方进行申明 但是使用只能在声明之后。

</br>

---

**输出函数**：

 printf函数的作用：<font color="red">**%d** 告诉 printf 用 num 的值替换掉 %d ，并且以
          **整数形式显示** num 的值(d 告诉 printf 以
          **十进制**整数的形式显示 num 的值)。</font>

**cout 与 printf 区别:**


> 如果已经习惯了C语言和`print()`，可能觉得cout看起来很奇怪。程序员甚至可能固执地坚持使用`print()`。但与使用所有转换说明的`print()`相比，cout的外观一点也不奇怪。更重要的是，cout还有明显的优点。它能够识别类型的功能表明，其设计更灵活、更好用。另外，它是可扩展的（extensible），也就是说，可以重新定义<运算符，使cout能够识别和显示所开发的新数据类型。如果喜欢`print()`提供的细致的控制功能，可以使用更高级的cout来获得相同的效果。
>
> 撇开`print()`的复杂性不说，必须用特殊代码（%s和%d）来指出是要打印字符串还是整数。如果让`print()`打印字符串，但又错误地提供了一个整数，由于`print()`不够精密，因此根本发现不了错误。它将继续处理，显示一堆乱码。

---



 **C++关键字**（一共32个）：

`auto`、`break`、`case`、`char `、`const`、`continue`、`default`、`do` 、`double`、`else`、`enum`、`extern` 、`float`、`for`、`goto`、`if `、`int`、`long`、`register`、`return` 、`short`、`signed`、`sizeof`、`static`、`struct`、`witch`、`typedef`、`union` 、`unsigned`、`void`、`volatile`、`while`.

当你作死想要用关键字作为变量名的时候也不是不可以，不要全局`using namespace std;`，你可以只是用`std::`达到相同的效果，然后用其他关键字做表，变量名……

</br>

---

**语句**(6种)：

> 声明语句：定义函数中使用的变量的名称和类型。
>
> 赋值语句：使用赋值运算符（=）给变量赋值。
>
> 消息语句：将消息发送给对象，激发某种行动。
>
> 函数调用：执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句。
>
> 函数原型：声明函数的返回类型、函数接受的参数数量和类型。
>
> 返回语句：将一个值从被调用的函数那里返回到调用函数中。

`if( )~else` 条件语句、`for( )~` 循环语句、`while( )~` 循环语句、`do~while( )` 循环语句、`continue` 结束本次循环语句、`break` 中止执行`switch`或循环语句、`switch` 多分支选择语句、`goto` 转向语句、`return` 从函数返回语句。

</br>

</br>

### 0x02 Doc

#### 后缀名(区别c和c++)

| C/C++ |  头文件后缀名  |       源文件后缀名       |
| :---: | :------------: | :----------------------: |
|   c   |       .h       |            .c            |
|  C++  | .h, .hpp, .hxx | .cpp  .cc .cxx  .C  .c++ |

另外，不同编译器和不同的操作系统对不同的版本有所区别：

![1521sA.png](https://s2.ax1x.com/2020/02/10/1521sA.png)

注意：

1. `.h`和`.hpp`的区别是：*.h里面只有声明，没有实现，而*`.hpp`里声明实现都有，后者可以减少`.cpp`的数量，适合用来编写公用的开源库。
2. `inl 文件`是内联函数的源文件。内联函数通常在c++头文件中实现，但有的时候内联函数较多或者出于一些别的考虑（使头文件看起来更简洁等），往往会将这部分具体定义的代码添加到`INL文件`中，然后在该头文件的末尾将其用`#include`引入。由此也可以看到`inl文件`的例外一个用法的影子——模板函数、模板类的定义代码的存放。

</br>

#### 争吵?

C++ 编写的程序，都能用等效的 C 程序代替，但 C++ 在语言层面上提供了 OOP/GP 语法、更严格的类型检查系统、大量额外的语言特性（如异常、RTTI等），并且 C++ 标准库也较丰富。有时候 C++ 的语法可使程序更简洁，如运算符重载、隐式转换。但另一方面，C 语言的 API 通常比 C++ 简洁，能较容易供其他语言程序调用。因此，一些 C++ 库会提供 C 的 API 封装，同时也可供 C 程序调用。相反，有时候也会把 C 的 API 封装成 C++ 形式，以支持 RAII 和其他 C++ 库整合等。

</br>

</br>

### 0x03  gcc & g++ 

> GCC（GNU Compiler Collection，GNU编译器套件）是由GNU开发的编程语言译器。GNU编译器套件包括C、C++、  Objective-C、 Fortran、Java、Ada和Go语言前端，也包括了这些语言的库（如libstdc++，libgcj等。） 

简单来说，gcc与g++都是GNU(组织)的一个编译器。需要注意以下几点：

1. gcc与g++都可以编译c代码与c++代码。后缀为.cpp的，两者都会认为是C++程序；但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；。
2. 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
3. 编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。

```shell
gcc main.cpp -lstdc++
```

</br>

</br>

### 0x04 Make/Compile

> 程序的生命周期是从一个高级C语言程序开始的（被人读懂）（高级编程语言）。为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列的低级机器语言指令。然后**这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来**。目标程序也称为可执行目标文件。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```shell
gcc-o hello hello.c
```

> 在这里，GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello，这个翻译过程可分为四个阶段<font color="red">（预处理器、编译器、汇编器和链接器）</font>，四个阶段的程序一起构成了**编译系统（compilation system）**。 ——摘自《深入理解计算机系统》
>

![15ge3Q.png](https://s2.ax1x.com/2020/02/10/15ge3Q.png)

1. **预处理(Pre-processing)**：编译器将C源代码中的包含的头文件如stdio.h添加进来。

```shell
gcc -E hello.c -o hello.i #将hello.c预处理输出hello.i文件
```
</br>

2. **编译(Compiling)**：gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言

```shell
gcc –S hello.i –o hello.s  #将预处理输出文件hello.i汇编成hello.s文件
```
</br>

3. **汇编(Assembling)**：把编译阶段生成的”.s”文件转成二进制目标代码“.o”文件

```shell
gcc –c hello.s –o hello.o #将汇编输出文件hello.s编译输出hello.o文件
```
</br>

4. **链接(Link)**：在成功编译之后，就进入了链接阶段

```shell
gcc hello.o –o hello #将编译输出文件hello.o链接成最终可执行文件hello
```


​    	运行该可执行文件，出现正确的结果如下

---

编译和链接的方式（Win）（其他平台后续再补）：

1. 下载一个在Windows命令提示符模式（在这种模式下，将于开一个类似王MS-DOS的窗口）下运行的免费命令行编译器。Cygwin和MinGW都包含编译器GNU C++，且可免费下载 它们使用的编译器名为gtt要使用g++编译器，首先需要打开一个命令提示符窗口。启动程序Cygwin和MinGw时，它们将自动为您打开一个命令提示符窗口。
   命令行编译器：`.c`用gcc，`.cpp`用g++，编译链接之后会生成一个按字母顺序的exe文件，例如`a.exe`文件。[![1IuY7T.th.png](https://s2.ax1x.com/2020/02/10/1IuY7T.th.png)](https://imgchr.com/i/1IuY7T)
   <font color="grey" size=2>这里说要提前下载一个编译器，但是我的电脑记得没有往环境变量里面添加这个，这个就有点迷???是Clion？？</font>
2. 通常，必须为程序创建一个项目，并将组成程序的一个或多个文件添加到该项目中。每个厂商提供的IDE（集成开发环境）都包含用于创建项目的菜单选项（可能还有自动帮助）。必须确定的非常重要的一点是，需要创建的是什么类型的程序。通常，编译器提供了很多选择，如Windows应用程序、MFC Windows应用程序、动态链接库、Activex控件、DOS或字符模式的可执行文件、静态库或控制台应用程序等。其中一些可能既有32位版本，又有64位版本.
   创建好项自后，需要对程序进行编译和链接。IDE通常提供了多个菜单项，如
   **Compile（编译）**对当前打开的文件中的代码进行编译。
   **Build（建立）、Make（生成）**：编译项目中所有源代码文件的代码。这通常是一个递增过程，也就是说，如果项目包含3个文件，而只有其中一个文件被修改，则只重新编译该文件。
   **Buld All（部建立）**重新编译所有的源代码文件。
   **Link（链接）**（如前所述）将编译后的源代码与所需的库代码组合起来。
   **Execute（执行）/Run（运行）**运行程序。通常，如果您还没有执行前面的步骤，Run将在运行程序之前完成这些步骤。
   **Debug（调试）**以步进方式执行程序
   编译器可能让您选择要生成调试版还是发布版。调试版包含额外的代码，这会增大程序、降低执行速度，但可捷供详细的调试信息



### 0x05 Variable

|          数据类型          |                     具体大小                     |
| :------------------------: | :----------------------------------------------: |
|       unsigned   int       |                  0～4294967295                   |
|            int             | <font color="red">-2147483648～2147483647</font> |
|       unsigned long        |                  0～4294967295                   |
|            long            |             -2147483648～2147483647              |
|     long long的最大值      |   <font color="red">9223372036854775807</font>   |
|     long long的最小值      |               -9223372036854775808               |
| unsigned long long的最大值 |               1844674407370955161                |
|      __int64的最大值       |               9223372036854775807                |
|      __int64的最小值       |               -9223372036854775808               |
|  unsigned __int64的最大值  |               18446744073709551615               |

注意：

1. 观察上面的规律： **负数的范围要比正数的范围大1 **、还有一点就是：**数据类型分配的字节数会根据机器的字长和编译器有所不同，不同的大小所表示的范围是不同的。上图唯一一个与机器有关的取值范围是 long 类型的，64位机器使用8个字节（264），而32位机器使用4个字节（232）**
2. C语言的int你会发现有多种不同的版本：有的最大是2^16^,有的最大是2^32^,其实这是**和你的机器和编译器的版本**有关的数据。前者是16位系统的，是最基本的设置，后者是32和64位的版本，**如果你想要最大是2^64^的话，在32位上使用`long long [int]`，在64位上使用`long [int]`**。这是区别。

</br>

#### 5.1  定义变量的考量

值得注意的是，在考虑程序的移植性的时候，应该兼顾16位系统的定义：

> 如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。这样，将程序移植到16位系统时，就不会突然无法正常工作，如果要存储的值超过20亿，可使用long long。

</br>

#### 5.2  整型字面值

> 整型字面值（常量）是显式地书写的常量，如212或1776，与C相同，C++能够以三种不同的计数方式来书写整数：基数为10、基数为8（老式UNIX版本）和基数为16（硬件黑客的最爱）。
>
> 这里将介绍C++表示法。C++使用前一（两）位来标识数字常量的基数。
>
> 如果第一位为`1~9`，则基数为10（十进制）；因此93是以10为基数的。
>
> 如果第一位是0，第二位为1~7，则基数为8（八进制）；因此`042`的基数是8，它相当于十进制数34。
>
> 如果前两位为Ox或0x，则基数为16（十六进制）；因此0x42为十六进制数，相当于十进制数66，对于十六进制数，字符`a~f`和`A~F`表示了十六进制位，对应于10~15，`OxF`为15，`OxA5`为165（10个16加5个1）。

```cpp
chest = 42; //(42 in decimal)
waist = 66; //(0x42 in hexadecimal )
inseam = 34; //(042 in octal)
```

</br>

#### 5.3 运算符的结合顺序

这个的重要性不言而喻，简单来说对于`20/4*5`到底是从左往右算，还是从右往左算的结果都是不一样的。因为乘除都是从左到右的，所以最后结果是`25`而不是`1`。运算符重载的`*`(取内容)`+`(取正)`-`(取负)的结合顺序是从右到左，但是相同符号下的加减运算是从左到右，这是容易搞混的点。







### 4.2 参数传递

包括形式参数、指针参数、引用参数、指针引用参数。形式参数，顾名思义，只是一个形式，最后不做保留；指针参数，将变量的地址传递到函数中，直接作用于main中的变量；引用参数，和指针略不同。

<font color="red">回去查了一下资料，以下列举：</font>

1.　<font color="red">这里存在一个小的知识点：new返回值是系统给的一片内存的首地址，所以申请内存只可以指针，用引用申请绝对是来捣乱的（手动滑稽）？！</font>
2.　<font color="red">指针数组是可以申请动态内存，但是函数体结束的时候该指针被回收，如果你没有及时把内存地址return回去，内存变成了鬼存（内存泄漏），你也不知道怎么使用。你也是来捣乱的（手动滑稽）</font>

以上，解释完了，另外还有应用的一个小知识，引用底层和指针相似，但是显示的是不占内存，而且在外函数内用完之后，其他函数是无法使用的.(我为什么回文如此脑残的问题？！)

```c++
int lfh(int a, int* b, int& c) {
	int sum = 0, sum1 = 1, sum2 = 0;
	int m = *b, n = c;
	for (int i = 1; i <= a; i++) sum += i;
	for (int i = 1; i <= m; i++) sum2 += i * i;
	for (int i = 1; i <= n; i++) sum1 *= i;
	*b = sum2;
	c = sum1;
	return sum;
}
```

</br>

#### 4.5 函数返回引用和返回值[·](https://blog.csdn.net/keyouan2008/article/details/5771844)

函数返回**值**时会产生一个临时变量作为函数返回值的副本，而返回**引用**时不会产生值的副本，既然是引用，那引用谁呢？以下是几种引用情况：

1. 引用函数的参数，当然该参数也是一个引用

```c++
const string &shorterString(const string &s1,const string &s2){
return s1.size()<s2.size()?s1:s2;
}
```

以上函数的返回值是引用类型。无论返回s1或是s2,调用函数和返回结果时，都没有复制这些string对象。简单的说，返回的引用是函数的参数s1或s2，同样s1和s2也是引用，而不是在函数体内产生的。

2. 千万不要返回局部对象的引用

```c++
const string &mainip(const string &s){
string ret=s;
return ret;
}
```

当函数执行完毕，程序将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。

</br>

</br>



### 0x09 Others

#### 10.1 `endl`和`\n`的区别

> 一个差别是换行符是一种被称为“转义序列”的按键组合，`endl`是一个特殊的C++符号，诸如`endl`等对于`cout`来说有特殊含义的特殊符号被称为控制符（manipulator）。和`cout`一样，`endl`也是在头文件iostream中定义的，且位于名称空间`std`中。
>
> 另外一个区别是`endl`确保程序继续运行前刷新输出（将其立即显示在屏幕上）；而使用`"\n"`不能提供这样的保证，这意味着在有些系统中，有时可能在您输入信息后才会出现提示。

#### 10.2 如何操作内存

> 计算机是一种精确的、有条理的机器。要将信息项存储在计算机中，必须指出信息的存储位置和所需的内存空间。在C++中，完成这种任务的一种相对简便的方法，是使用声明语句来指出存储类型并提供位置标签。

#### 10.3 强语言类型的优点

> 有些语言（最典型的是BASIC）在使用新名称时创建新的变量，而不用显式地进行声明。这看上去对用户比较友好，事实上从短期上说确实如此。问题是，如果错误地拼写了变量名，将在不知情的情况下创建一个新的变量。在BASIC中，ss程序员可能编写如下语句：
>
> ```basic
> CastleDark = 34
> CastleDank= CastleDark+MoreGhosts 
> PRINT CastleDark
> ```
>
> 由于CastleDank是拼写错误（将r拼成了n），因此所作的修改实际上并没有修改CastleDark。这种错误很难发现，因为它没有违反BASIC中的任何规则。然而，在C++中，将声明`CastleDark`，但不会声明被错误拼写的`CastleDank`，因此对应的C++代码将违反“使用变量前必须声明它”的规则，因此编译器将捕获这种错误，发现潜在的问题。

#### 10.4 数组扩容

不存在任何扩容操作，所谓扩容就是申请更大的数组拷贝过去，即所谓的伪扩容。

类似的还有数组的删除操作，思路如下：

![数组删除](http://i.dfslfh.cn/数组删除.png)

<br/>

#### 10.5 输出ASKII码 

将char转化int即得。值得注意的是 两位数字不是没有askii码 而是他的码是八位。

值得注意的是，字符数组的初始化为数字 `0`的时候数组内全补充的`\0`（全局变量也可以达到这个效果）,有的时候用动态申请内存的时候，无法保证最后一位的下一位是`\0`来保证数组停下来（判断条件是`p[i]！=‘\0’ `）,所以应该尽量避免这样的判断条件，如果一定要用这个条件，可以选择初始化的时候就全员`\0`.

#### 10.6 `for`&`while`

做题存在的问题——`for`不超`while`超时.

+ 从内存角度考虑:

  + 局部变量在栈内存中存在,当for循环语句结束,那么变量会及时被gc(垃圾回收器)及时的释放掉,不浪费空间
  + 如果使用循环之后还想去访问循环语句中控制那个变量,使用while循环

+ 应用场景 

  + 如果一个需求明确循环的次数,那么使用for循环(开发中使用for循环的几率大于while循环)
  + 如果一个需求,不知道循环了多少次,使用while循环
  

#### 10.7 保留小数

```cpp
cout<<setiosflags(ios::fixed)<<setprecision(2);//第一种写法

cout.setf(ios::fixed)；
cout<<setprecision(2);//第二种写法

cout<<fixed<<setprecision(2);//第三种写法
```

其中：

1. `setprecision(n)`：功能是控制浮点数显示的有效数字个数。
   有意思的是：

   ```cpp
   int main() {
   	double p = 12.56;
   	cout << setprecision(1) <<p<< endl;
   }
   ```

   运行结果：`1e+01`.

2. **`showpoint`：显示一个小数点**

3. **`fixed`：**`setprecision(n)`和`fixed`合用的话可以控制小数点后有几位，只要加上以下**任意一个**语句就可以。

   ```cpp
   cout<<setiosflags(ios::fixed);
   cout.setf(ios::fixed);
   cout<fixed;
   ```

#### 10.8 `while(cin>>a)`

**cin>>a的过程是先取得从键盘的输入值a，并将a赋给cin**

如果[输入流](https://www.baidu.com/s?wd=输入流&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)（输入的值有效）正常，就会继续循环获取键盘值，如果[输入流](https://www.baidu.com/s?wd=输入流&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)错误，或者达到文件末尾（在windows下`Ctrl+Z`，在Linux下`Ctrl+D`），该循环就会终止。输入缓冲是行缓冲。当从键盘上输入一串字符并按回车后，这些字符会首先被送到输入缓冲区中存储。每当按下回车键后，cin.get()  就会检测输入缓冲区中是否有了可读的数据。cin.get()  还会对键盘上是否有作为流结束标志的  `Ctrl+Z ` 或者  `Ctrl+D ` 键按下作出检查，其检查的方式有两种：阻塞式以及非阻塞式。(这里有检查而宏定义中没有检查！！!)

 Windows系统中一般采用阻塞式检查 `Ctrl+Z`、Unix/Linux系统下一般采用非阻塞式的检查  Ctrl+D。

 这种阻塞式的方式有一个特点：

1. 只有按下回车之后才有可能检测在此之前是否有`Ctrl+Z`按下。
2. 如果输入缓冲区中有可读的数据则不会检测`Ctrl+Z`（因为有要读的数据，还不能认为到了流的末尾）。
3. Ctrl+Z产生的不是一个普通的ASCII码值，也就是说它产生的不是一个字符，所以不会跟其它从键盘上输入的字符一样能够存放在输入缓冲区。明白了这几点之后就可以来解释楼主提出的问题了。

因此，输入流结束的条件就是：`^z ` 之前不能有任何字符输入（回车除外），否则  ^z  起不到流结束的作用。相似地，如果在按 ` Ctrl+D ` 之前已经从键盘输入了字符，则  `Ctrl+D`的作用就相当于回车，即把这些字符送到输入缓冲区供读取使用，此时`Ctrl+D`不再起流结束符的作用。如果按 `Ctrl+D  `之前没有任何键盘输入，则`  Ctrl+D  `就是流结束的信号。

阻塞式检查方式指的是只有在回车键按下之后才对此前是否有  Ctrl+Z  组合键按下进行检查，非阻塞式样指的是按下  Ctrl+D  之后立即响应的方式。例如：

从键盘上输入abcd^z  加  回车之后在Windows系统上是这样处理的：由于回车的作用，前面的  abcd  等字符被送到输入缓冲区（注意：上面说过了，^z不会产生字符，所以更不会存储到输入缓冲区，缓冲区中没有  ^z  的存在）。这时，cin.get()  检测到输入缓冲区中已经有数据存在（因此不再检查是否有  ^z  的输入），于是从缓冲中读取相应的数据。如果都读取完了，则输入缓冲区重新变为空，cin.get()  等待新的输入。可见，尽管有  ^z  按下，但是由于在此之前还有其它输入字符（abcd），所以流也不会结束。





#### 10.9 主函数的返回类型 

1. `void`,即无返回值
2. ` int`,返回int型

`main`的返回值是返回给系统的,0表示成功,其他为失败。有的时候`int `返回值不写也是可以的如果没有值被返回，系统将得到一个表示程序成功完成的值。来自`main()`的非0值表示出错。





#### 10.10 宏定义

define的定义更像是简单的文本替换，而不是作为一个量来使用

```cpp
#define Add(a,b) a+b;
```

在一般使用的时候是没有问题的，但是如果遇到如：c * Add(a,b) * d的时候就会出现问题，代数式的本意是a+b然后去和c，d相乘，但是因为使用了define（它只是一个简单的替换），所以式子实际上变成了` c*a + b*d`.

```cpp
#include<iostream>
#define f(x) x*x
using namespace std;
int main(){
	int a = 6.0, b = 2.0;
	cout << double(f(a)) / double(f(b)) << endl;
	cout << sizeof(f(a) / f(b)) << endl;//具体的4去哪里了？？？
}
```

**在大规模的开发过程中，特别是跨平台和系统的软件里，define最重要的功能是条件编译**

```cpp
#ifdef WINDOWS
......
......
#endif
#ifdef LINUX
......
......
#endif
```

可以在编译的时候通过#define设置编译环境

<br/>

#### 10.11 截取数字数组的长度

由于字符的长度可以用`strlen`截取，所以我数字字符就看着眼红，自己无聊的时候手写了一个(前提是必须最后一位有`\0`)

```cpp
#define LENGTH(ii) int ii=0;for(ii=0;p[ii]!='\0';ii++);
//用法
LENGTH(step);
cout << step;
```

第二种

```cpp
int Length(int p[]) {
	int step, ii = 0;
	for (ii = 0; p[ii] != '\0'; ii++);
	return ii;
}
```









### 2.∞ 细枝末节

1. 在有些语言中，有返回值的函数被称为函数（function）；没有返回值的函数被称为过程（procedure）或子程序（subroutine），但C++与C一样，这两种变体都被称为函数。
2. 数组初始化的问题，不可以写`int p[N]`但是Devcpp里面却可以，这是因为C语言C99标准里的变长数组VLA,c++标准不支持。gcc编译器支持变长数组,但vc那个编译器不支持。你搜一下变长数组。会有很多这个资料的。
3. 二维数组初始化不可以用（）因为会识别为逗号表达式，返回最后的值。











### Reference：

参照的来源不限于：

[1] : [C++诞生历史](https://blog.csdn.net/zxxssdsd/article/details/9309203).

[2] : ISO/IEC 9899:1999 (E) Programming languages — C 5.1.2.2.1 Program startup

[3] : ISO/IEC 14882(1998-9-01)Programming languages — C++ 3.6 Start and termination

[4] : [C/C++ 误区二：void main()](https://blog.csdn.net/fengyuruhui/article/details/1682319).

[5] : C++ Primer Plus（第6版）中文版

[6] : [C++重载](http://c.biancheng.net/cpp/biancheng/view/3016.html) .

