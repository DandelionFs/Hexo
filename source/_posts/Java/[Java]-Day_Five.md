---
title: '[Java]Day Five'
---



### 5.2.    this关键字

**Q:**`a.peel(1), b.peel(2)`如何识别

> **A:** 
>
> 为了能用简便、面向对象的语法来编写代码-即“发送消息给对象”，编译器做了一些幕后工作。它暗自把“所操作对象的引用”作为第一个参数传递给peel()
>
> 假设你希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：this，this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用.this的用法和其他对象引用并无不同。但注意，**如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可**。
>
> 由于函数成员通过this关键字返回了对当前对象的引用，所以很容易在一条语句里对同个对象执行多次操作。即对多个函数进行嵌套处理.

<br>

**Static 关键字**(Page 86)

在static方法的内部不能调用非静态方法，反过来倒是可以的. 

> 并不是完全不可能。如果你传递一个对象的引用到静态方法里（静态方法可以创建其自身的对象），然后通过这个引用（和tis果相同），你就可以调用非静态方法和访问非静态数据成员了。但通常要达到这样的效果，你只需写一个非静态方法即可。

static全局变量 和 面向对象 的天然冲突???

> 的确，要是在代码中出现了大量的statie方法，就该重新考虑自己的设计了。然而，static的概念有其实用之处，许多时候都要用到它。至于它是否真的“面向对象”，就留给理论家去讨论吧。事实上，Smallalk语言里的“类方法”就是与static方法相对应的。

<br>

<br>

### 5.3.    清理：终结处理和垃圾回收

+ GC仅负责new出来的对象; “本地方法”分配的内存，GC无法回收

+ finalize() : GC (Garbage Collection) 前，调用 finalize();  GC，回收对象内存

> 一旦 GC(garbage collector) 准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。
>
> 1. 对象可能不被垃圾回收。
> 2. 垃圾回收并不等于“祈构”。垃圾回收只与内存有关
> 3. 绝对不能直接调用finalize()
>
> 这意味着在你不再需要某个对象之前，如果必须执行某些动作那么你得自己去做。也许你会发现，只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到解放。如果程序执行结束，并且垃圾回收器一直都没有释放你创建的任何对象的存储空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。

<br>

**如何工作?**

> 存储空间的释放竟然会影响存储空间的分配，是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。









### 5.4.    对象的创建过程

+ 首次创建Dog对象、访问Dog静态方法，Java解释器定位Dog.class

+ 载入Dog.class，静态初始化

+ new Dog()时，在堆上分配空间

+ 存储空间清零
  + 基本类型→默认值
  + 引用→null

+ 执行字段定义处的初始化动作

+ 执行构造器





### 5.5.    初始化

**静态初始化**

+ static{}
+ 首次加载类时执行（即使未生成类对象）

**非静态初始化**

+ {}
+ 生成对象时执行，匿名内部类的初始化

**构造器（最后执行）**





### 5.6.    枚举类型

**enum类→编译器行为**



**特性**

+ toString()
+ ordinal()
+ 特定enum常量的声明顺序
+ values()
+ 按顺序生成数组



## 0x06 访问控制权限

> 如何把变动的事物和保持不变的事物区分开来?

不过，构件类库的概念以及对于谁有权取用该类库构件的控制问题都还是不完善的。其中仍旧存在着如何将构件捆绑到一个内聚的类库单元中的问题。对于这一点，Java用关键字package加以控制，而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。为此，要开始学习本章，首先要学习如何将类库构件置于包中，然后就会理解访问权限修饰词的全部含义。



我们之所以要导入，就是要提供一个管理名字空间的机制。所有类成员的名称都是彼此隔离的。A类中的方法f0与B类中具有相同特征标记（参数列表）的方法f0不会彼此冲突。但是如果类名称相互冲突又该怎么办呢？假设你编写了一个Stack类并安装到了一台机器上，而该机器上已经有了一个别人编写的Stack类，我们该如何解决呢？由于名字之间的潜在冲突，在Java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事1



当编写一个Java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名java），每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。







### 6.1 为什么控制访问权限？

+ 使用户不触碰不该触碰的部分

+ 更改内部实现，不影响客户端程序员





## 6.2.    访问权限关键字

+  public

+  protected
   + 继承的类+同包的类

+  **default**
   + 同包的类

+  private





## 6.3.    类的访问权限

+ 可以: public,  default

+ 不可以（特例：内部类）:private, protected





# 7.   第7章 复用类

## 7.1.    如何复用？

### 7.1.1.  组合

·    新类中，产生现有类的对象

### 7.1.2.  继承

·    按照现有类型，进行复用

·    调用导出类，先加载基类

·    @Override

•   确保覆盖，而非重载

### 7.1.3.  代理

·    继承和组合的中庸之道

·    成员对象→构造的类中（组合）

·    在新类中暴露成员对象的所有方法（继承）

## 7.2.    在组合与继承之间选择

### 7.2.1.  组合

·    显式：在新类中放置子对象

·    复用具体实现，而非接口

### 7.2.2.  继承

·    隐式：在新类中放置子对象

·    新类→基类，复用接口

### 7.2.3.  向上转型

·    新类是现有类的一种类型

·    类接口可能丢失方法

## 7.3.    final关键字

### 7.3.1.  数据

·    基本类型

·    引用

•   引用所指向的对象恒定不变

•   指向对象的内容，可以更改

·    参数

•   无法改变参数所指向的对象

### 7.3.2.  方法

·    防止继承类覆盖

·    private方法隐式地为final的

•   无法获取→无法覆盖

### 7.3.3.  类

·    无法被继承

·    Java的final类

•   基本类型的包装类

•   字符串

•   String

•   StringBuilder

•   StringBuffer

•   数学

•   Math

•   StrictMath

•   系统

•   System

•   Class

# 8.   第8章 多态

## 8.1.    对比

### 8.1.1.  多态

·    分离：做什么↔怎么做，消除类型间的耦合关系

### 8.1.2.  封装

·    合并：特征↔行为，创建新的数据类型

### 8.1.3.  实现隐藏

·    分离：接口↔实现，将细节私有化

## 8.2.    问题

### 8.2.1.  基类的引用，如何找到继承类的方法？

## 8.3.    答案

### 8.3.1.  编译器不知道对象的类型

### 8.3.2.  运行时判断对象的类型，找到正确的方法体

## 8.4.    准则

### 8.4.1.  继承：表达行为（方法）间的差异

### 8.4.2.  组合：状态（对象）上的变化

# 9.   第9章 接口

## 9.1.    关系

### 9.1.1.  普通类→抽象类→接口

## 9.2.    抽象类和抽象方法

### 9.2.1.  抽象方法

·    仅有声明，没有方法体

·    abstract void f()

### 9.2.2.  抽象类

·    包含抽象方法的类

•   编译器阻止实例化

·    可以不包含抽象方法

•   阻止创建实例

·    重构工具

•   公共方法→继承层次向上移动

## 9.3.    接口

### 9.3.1.  含义

·    完全抽象的类

•   没有任何方法体

•   域

•   隐式：static, final

•   Java 5前，创建常量组的工具（enum）

•   不能是“空final”

•   可以被非常量表达式初始化

·    所有实现了特定接口的类，看起来都像这样

·    类与类之间的协议

### 9.3.2.  作用

·    完全解耦

•   “忽略”继承层次

·    实现“多重继承”

•   接口的组合

### 9.3.3.  为什么使用接口？

·    1.能向上转型为多个基类型

·    2.防止创建该类的对象

### 9.3.4.  接口与工厂

·    工厂方法

•   工厂对象→创建方法

•   生成接口的某个实现的对象

·    好处

•   代码完全与接口的实现分离

•   透明地将某个实现，替换成另一个实现













引用的效果和C++比起来有什么不一样的地方???

